---
title: "DSA 2021 - TD R"
author: "Fabien FAIVRE"
date: "18 juillet 2021"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
    number_sections: true
    theme: lumen
    code_folding: hide
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

# Présentation du projet

Ce projet s'inscrit dans le cadre de la formation [DSA](https://www.institut-du-risk-management.fr/nos-formations/formations-certifiantes/certificat-data-science-pour-actuariat/), et évalue l'apprentissage de R réalisé auprès de **Robin RYDER**.

Le thème de ce projet est libre.

> J'ai choisi d'étudier la manière dont les approches de machine learning (ci après `ML`) peuvent compléter les approches classiques par modèles linéaires généralisés (`GLM`) dans le cadre de la tarification en assurance non-vie.

## Les bonnes propriétés du GLM dans le cadre d'une modélisation de la fréquence de sinistres

Soit $N_{i}$ le nombre de sinistre de la police ${i}$, alors dans le modèle Poisson homogène on suppose $N_{i} \sim \mathscr{P}(\lambda \nu_{i})$ où $\nu_{i}$ est l'exposition au risque de la police $i$, $\lambda$ est la fréquence de sinistre annuelle (homogène sur le portefeuille)et $\mathscr{P}$ la loi de Poisson.
On pose $Y_{i} = \frac{N_{i}}{\nu_{i}}$ la fréquence annuelle des sinistres pour la police $i$ et $\mathbf{x_{i}}=(x_{1},x_{2},..., x_{q})$ les $q$ caractéristiques de la police $i$.

En tarification, on suppose dans les faits que $\lambda$ dépend de $\mathbf{x}$, de sorte que $\mathbb{P}[Y=k/\nu] = \mathbb{P}[N=k] = e^{-\lambda(\mathbf{x})\nu} \frac{(\lambda(\mathbf{x})\nu)^{k}}{k!}$ avec $ln(\lambda(\mathbf{x})) = \beta_{0} + \beta_{1}x_{1} + \beta_{2}x_{2} + \cdots + \beta_{q}x_{q} \overset{def}{=} \langle \mathbf{\beta}, \mathbf{x} \rangle$ en complétant $\mathbf{x}$ par $x_{0} = 1$.

Lorsqu'on utilise les approches classiques de GLM, on estime $\hat{\lambda}$ en utilisant l'estimateur du maximum de vraisemblance $\hat{\beta}$ de $\beta$.

Cet estimateur peut être obtenu soit en maximisant la log vraisemblance, soit de manière équivalente en minimisant la déviance de Poisson.

En complément, lorsqu'on utilise un GLM incluant un intercept et sa fonction de lien canonique, l'utilisatiuon d'un estimateur du maximum de vraisemblance apporte de bonnes propriétés pour son usage en tarification dont celle dite de **propriété d'équilibre** (Property 2.4 p33 de [Data Analytics for Non-Life Insurance Pricing](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2870308)), qui précise que :

$\displaystyle\sum_{i=1}^{n} \nu_i\hat{\lambda}(\mathbf{x_{i}}) = \displaystyle\sum_{i=1}^{n} \nu_i exp\langle \mathbf{\hat{\beta}}, \mathbf{x_{i}} \rangle = \displaystyle\sum_{i=1}^{n} N_{i}$

De sorte que le nombre total de sinistres estimés est égale au nombre total de sinistres observés.

Cette propriété est même plus étendue dans certains modèles GLM, notamment lorsque le modèle poissonien avec lien log (exemple (b) p423 de [A systematic relationship between minimum bias and gener- alized linear models](https://www.casact.org/sites/default/files/2021-02/pubs_proceed_proceed99_99317.pdf)) : dans ce cas l'équilibre existe au global du portefeuille, mais aussi pour chaque classe des variables catégorielles incluses dans le modèle.

**Ces propriétés d'équilibres sont critiques pour un assureur** dans un exercice de tarification, puisqu'elles assurent qu'une structure tarifaire basée sur cette approche lui permettra d'équilibrer (au moins théoriquement) ses encaissement avec les sinistres qu'il s'est engagé à indemniser.

Le GLM est donc interprétable, souple à l'usage et présente des propriétés d'équilibre global et local.
Néanmoins son ajustement nécessite un temps humain important et le praticien doit s'en remettre à son expérience pour estimer les éventuelles interactions à inclure dans son analyse.

## L'apport et les limites des modèles ML en tarification

Les modèles ML par leur grande flexibilité sont des candidats naturels pour remplacer ou à minima compléter les modèles GLM du fait de leur performance sur une grande variété de cas d'usages ces dernières années.
Toutefois, ces modèles nécessitent qulques ajustements avant de pouvoir être utilisés dans des problèmes de tarification.

### Ajustement \#1 : définition de la fonction de perte

Une première adaptation des modèles classiques consiste donc à **définir la déviance de poisson comme fonction de perte des algorithmes de ML**.

C'est notamment l'approche préconisée par dans [Data Analytics for Non-Life Insurance Pricing](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2870308) de Mario V. Wuthrich et Christoph Buser.

### Limites de la modification de la fonction de perte

La définition d'une fonction de perte appropriée est devenue l'approche par défaut de l'utilisation des méthodes ML en tarification.
Néanmoins, dès 2019 Wütrich remarqua que les sinistres estimés par les modèles ML ne correspondaient pas à la sinistralité observée sur le portefeuille, même sur le jeu d'entraînement

> Il semble que l'utilisation directe de modèles de ML, mêmes adaptés pour minimiser la déviance, ne présentent pas les garanties d'équilibre des GLM.

Les modèles de ML permettent une meilleurs corrélation avec la réponse individuelle de chaque police, du fait de la plus grande flexibilité accordée à la forme de la contribution (éventuellement non linéaire) de chaque variable à la sortie.
Toutefois, cette meilleure corrélation s'obtient au prix de l'abandon de la notion d'équilibre.
En effet, aucune garantie n'est expressément introduite au global du portefeuille ce qui peut produire des divergences, potentiellement importantes, entre la somme des primes demandées et les sinistres que l'assureur s'est engagé à régler.

Cet effet est attribué par M Wütrich aux conditions d'arrêt précoce des algorithmes d'optimisation utilisés par les modèles ML.

## Pistes de réconciliation des approches GLM et ML pour la tarification

Deux options s'offrent dès lors à l'actuaire :

1.  essayer d'extraire des informations de la manière dont les modèles ML ont appris les efefts des variables sur la sortie pour compléter les GLM classiquement manipulés avec l'objectiof de combler en partie l'écart de performance (s'il est important) avec le modèle ML tout en conservant les propriiétés et l'interprétabilité naturelle des modèles GLM.
    C'est la voie suivie par l'article [Peeking into the black box](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3595944) de Christian Lorentzen et Michael Mayer

2.  corriger les approches ML en les combinant avec une approche GLM pour en récupérér les propriétés.
    Le gain de cette approche devrait être plus important que pour la méthode précédente tout en présentant les propriétés d'équilibre des modèles ML sans toutefois apporter l'interprétabilité de ces modèles.
    C'est la proposition de de Michel Denuit, Arthur Charpentier et Julien Trufin dans [Autocalibration and Tweedie-dominance for Insurance Pricing with Machine Learning](https://arxiv.org/abs/2103.03635) repartent du constat de Wütrich et proposent une solution de contournement sous la forme d'un ajustement en deux temps successifs :

    1.  Dans un premier temps, un modèle ML est ajusté pour déterminer une première estimation $\hat{\pi}$ des primes théoriques

    2.  Dans un deuxième temps, ces primes théoriques $\hat{\pi}$ sont utilisées comme variable entrante d'un modèle d'autocalibration local pour produire des primes corrigées $\widehat{\pi_{BC}}$.
        Cette méthode consiste à ajuster des modèles GLM locaux réduits à un intercept sur des ensembles de points "proches".
        La notion de proximité ici se fait qui sont définis à partir de la proximité des primes théoriques estimées par ML $\hat{\pi}$ (l'étape de ML rassemble les observations qui se ressemblent, l'étape locale GLM lisse les écarts entre observations voisines pour retrouver les propriétés d'équilibre).

## Objectif du projet

Dans ce rapport, faute de temps, nous n'explorerons que l'option 1 en commençant par comparer la performance d'un modèle GLM classique avec un modèle GBM et un modèle XGBoost.

Nous tâcherons de comprendre la manière dont les modèles ML ont appris les relations entre les variables pour dans un troisième temps proposer une version améliorée du GLM initial.

Pour ce faire, nous prendrons comme base d'analyse le jeu de données tarifaire d'un portefeuille MRH qui nous avait été confié lors du Hackathon.

L'enjeu étant surtout d'illustrer le principe, nous nous restreindrons dans la suite de ce document à l'analyse de la seule fréquence des sinistres.

# Analyse

## Mise en place de l'environnement

Le code suivant est un ensemble d'utilitaire pour naviguer dans les répertoires relatifs du projet et installer ou charger les packages nécessaires à l'analyse :

```{r echo=T, results='hide', message=FALSE, warning=FALSE}
if (!require("here")){ 
  install.packages("here") 
  library("here")
}

set_here

LoadPackage <- function (load.lib=c("")) {

  install.lib<-load.lib[!load.lib %in% installed.packages()]
  for(lib in install.lib) install.packages(lib,dependencies=TRUE)
  sapply(load.lib,require,character=TRUE)
  
}


LoadPackage(c('ggplot2', 'dplyr', 'formattable', 'DT', 'tidyr', 'caret', 'plotly', 'xgboost', 'flashlight', 'MetricsWeighted', 'corrplot', 'lsr', 'h2o', 'wesanderson', 'locfit'))
```

## code pour la phase exploratoire

Dans cette section nous allons définr deux fonctions qui seront utilisées de manière répétées dans la phase exploratoire du jeu de données à savoir une fonction générique de tracé des exprositions et fréquences moyennes de sinistres d'une part et de création de tables synthétiques d'autre part :

```{r echo=T}


plot_obs<-function(df,feature,use_year=T) {

    if (use_year) {
          dt <-df %>%
          group_by(df[[feature]], ANNEE, .drop=FALSE) %>%
          summarise(Freq = sum(NB*EXPO)/sum(EXPO), nb_lignes = n(), EXPO=sum(EXPO) ,  pct_EXPO = sum(EXPO) /  sum(df$EXPO)) %>%
          rename(feat = 'df[[feature]]') 
    } else {
          dt <-df %>%
          group_by(df[[feature]], .drop=FALSE) %>%
          summarise(Freq = sum(NB*EXPO)/sum(EXPO), nb_lignes = n(), EXPO=sum(EXPO) ,  pct_EXPO = sum(EXPO) /  sum(df$EXPO)) %>%
          rename(feat = 'df[[feature]]') 
    }
    
    
    
    fig <-plot_ly()
    fig <- fig %>% layout(title = paste0('Fréquence de sinistres par ', feature),
             xaxis = list(title = feature),
             yaxis = list(side = 'left', title = 'Exposition', showgrid = FALSE, zeroline = FALSE),
             yaxis2 = list(side = 'right', overlaying = "y", title = 'Fréquence', showgrid = FALSE, zeroline = FALSE))
    
    if (use_year) {
        for (year in unique(dt$ANNEE)) {
        
              dt_temp <- dt %>% filter(ANNEE==year)
              fig <- fig %>% add_trace( 
                             x= dt_temp$feat, y= dt_temp$EXPO, type = 'bar', name = paste0('Exposition_', year),
                             hovertemplate = 'Expo: %{y:.0f}<br>'
                          )
              fig<- fig %>% add_trace(
                             x= dt_temp$feat, y= dt_temp$Freq, type = 'scatter', mode = 'lines', yaxis = 'y2', name= paste0('Fréquence_', year),
                             hovertemplate = 'Freq: %{y:.2%}<br>'
                            )
        
        }
    } else {
              dt_temp <- dt 
              fig <- fig %>% add_trace( 
                             x= dt_temp$feat, y= dt_temp$EXPO, type = 'bar', name = 'Exposition',
                             hovertemplate = 'Expo: %{y:.0f}<br>'
                          )
              fig<- fig %>% add_trace(
                             x= dt_temp$feat, y= dt_temp$Freq, type = 'scatter', mode = 'lines', yaxis = 'y2', name= 'Fréquence',
                             hovertemplate = 'Freq: %{y:.2%}<br>'
                            )
      
    }
    
    return(fig) 
}


```

```{r echo=T}
resume <- function(df, feature) {

    dt <-df %>%
      group_by(df[[feature]], .drop=FALSE) %>%
      summarise(Freq = sum(NB*EXPO)/sum(EXPO), nb_lignes = n(), EXPO=sum(EXPO) ,  pct_EXPO = sum(EXPO) /  sum(df$EXPO ))
    
    colnames(dt)[1] <- feature
    
    
    table<- formattable(dt,
                align = c("l", rep("r", NCOL(dt) - 1)),
                list(
                    Freq = percent,
                    nb_lignes= accounting,
                    EXPO = accounting,
                    pct_EXPO = percent
                )
    )
  
    fig1<- plot_obs(df, feature, use_year = F)
    
    fig2<- plot_obs(df, feature, use_year = T)
    
    return(list(dt=dt, table=table, fig=fig1, figyr=fig2))
}
```

# Présentation du jeu de données

Le jeu de données est constitué de 4 fichiers :

```{r data}
list.files(path=here('data', 'raw'))
```

Le projet suit un portefeuille d'assurance MRH suivi sur plusieurs années de 2016 à 2018 inclus.
L'objectif initial du Hackathon est d'estimer les primes 2019 sur un échantillon de contrats.

La nature de la garantie modélisée ne nous a pas été communiquée.

Pour éviter les redondances, les analyses descriptives sont concentrées sur le fichier combiné en fin de section.

## expo_train

Le fichier `expo_train.csv` contient la liste des contrats en risques historiquement suivis :

```{r}
expo_train = read.table(file = here('data', 'raw', 'expo_train.csv'), header=T, sep=',', dec='.', encoding = 'UTF-8', stringsAsFactors = T)

datatable(head(expo_train))

str(expo_train)
```

Les données ont été prétraitées pour disposer d'**une ligne par période de risque annuelle homogène**.

Pour des raisons d'anonymisation, les identifiants contrats ont été supprimés de sorte qu'il n'est pas possible de suivre l'évolution du risque d'une période sur l'autre.
Pour la même raison, il ne sera pas possible dans la construction des jeux de validation et de test de s'assurer que toute l'expérience d'un même assuré est bien intégralement dans un jeu d'entraînement, de validation ou de test.

La signification des colonnes présentes est la suivante :

-   **`X`**: variable non nommée. Il s'agit d'un artefact du processus de création du fichier initial. **On ne la prend pas en compte**
-   **`EXPO`** : exposition en année risque du contrat. Sa valeur précalculée pour chaque ligne est comprise entre 0 et 1
-   **`FORMULE`** : variable catégorielle codant la formule du contrat comprenant 3 niveaux `MEDIUM`, `ESSENTIEL` et `CONFORT`
-   **`TYPE_RESIDENCE`** : variable catégorielle codant le fait que le bien est une résidence `PRINCIPALE`, ou `SECONDAIRE`
-   **`TYPE_HABITATION`** : variable catégorielle codant le fait que le bien est un `APPARTEMENT`, ou une `MAISON`
-   **`NB_PIECES`** : variable numérique indiquant le nombre de pièces du logement
-   **`SITUATION_JURIDIQUE`** : variable catégorielle indiquant si le souscripteur est prorpiétaire (`PROPRIO`) ou locataire (`LOCATAIRE`) du logement assuré
-   **`NIVEAU_JURIDIQUE`** : variable catégorielle codant le niveau de couverture de la garantie juridique
-   **`VALEUR_DES_BIENS`** : variable numérique reflétant la valeur couverte du contenu du logement
-   **`OBJETS_DE_VALEUR`** : variable catégorielle codant le niveau de couverture des objets
-   **`ZONIER`** : variable catégorielle codant la zone du bien assuré. Le code est constitué d'une lettre représentant une zone et d'un nombre représentant une partie de la zone
-   **`NBSIN_TYPE1_AN1`** : variable numérique indiquant le nombre de sinistre de type 1 l'année précédente
-   **`NBSIN_TYPE1_AN2`** : variable numérique indiquant le nombre de sinistre de type 1 il y a 2 ans
-   **`NBSIN_TYPE1_AN3`** : variable numérique indiquant le nombre de sinistre de type 1 il y a 3 ans
-   **`NBSIN_TYPE2_AN1`** : variable numérique indiquant le nombre de sinistre de type 2 l'année précédente
-   **`NBSIN_TYPE2_AN2`** : variable numérique indiquant le nombre de sinistre de type 2 il y a 2 ans
-   **`NBSIN_TYPE2_AN3`** : variable numérique indiquant le nombre de sinistre de type 2 il y a 3 ans
-   **`id`** : identifiant du risque, clef de jointure
-   **`ANNEE`** : variable catégorielle indiquant l'année d'observation du risque : `2016`, `2017`, `2018`

## sin_train

Le fichier `expo_train.csv` contient la liste des contrats en risques historiquement suivis :

```{r}
sin_train = read.table(file = here('data', 'raw', 'sin_train.csv'), header=T, sep=';', dec=',', encoding = 'UTF-8', stringsAsFactors = T)

datatable(head(sin_train))

str(sin_train)
```

-   **`id`** : identifiant du risque, clef de jointure avec le fichier `expo_train`

-   **`NB`** : Nombre de sinistres de la typologie modélisée (inconnue) sur la période d'observation

```{r echo=FALSE}

dt <-sin_train %>%
  group_by(NB) %>%
  summarise(nb_lignes = n())


formattable(dt,
            align=c('l','r'),
            list(
                nb_lignes= accounting
            )
)


dt %>%
  ggplot( aes(x=as.factor(NB), y=nb_lignes, fill=as.factor(NB))) +
    geom_bar(stat='identity') +
    ggtitle('Distribution NB')+
    xlab('NB') +
    ylab('nombre de lignes') +
    labs(fill = 'NB')
  
```

## fichier combiné

On peut désormais combine les information d'exposition et de sinistres :

```{r}
mrh <- expo_train %>%
      left_join(sin_train, by =c('id','ANNEE')) %>%
      replace_na(list('NB'=0, 'COUT'=0))
```

N'ayant pas accès au fichier de test utilisé lors du Hackathon, on dissocie ici le fichier mrh en un fichier `train` (70%), un fichier `val` (20%) et un fichier `test` (10%).
Cette approche est prise ici sans considération des années d'étude.

C'est un biais fort qui aurait été **rédhibitoire dans la réalité** puisqu'il aurait été de nature à induire des effets de leakage entre les jeu d'entrainement et de test.

Toutefois cette approche a été prise par commodité et pour garder une proportion significative de volume dans les jeux de validation et test et parce que l'enjeu de l'analyse n'est pas nécessairement la performance réelle des algorithmes, mais plutôt la démarche pour augmenter les modèles GLM à partir des informations extraites des modèles ML.

Nous utilisons ici la fonction `createDataPartition` du package `caret` qui permet de faire du stratified sampling par rapport à une variable d'entrée.

```{r}
set.seed(42)

trainIndex<- createDataPartition(mrh$NB>=0, p=.7, list=FALSE, time=1)

mrh_train<-mrh[trainIndex,]
mrh_test<-mrh[ -trainIndex,]

valIndex<- createDataPartition(mrh_test$NB>=0, p=.66, list=FALSE, time=1)
mrh_val<-mrh_test[ valIndex,]
mrh_test<-mrh_test[ -valIndex,]

```

### Taux de sinistres moyen :

```{r}
tx <- sum(mrh_train$NB)/sum(mrh_train$EXPO)

print(paste0('taux de sinistre moyen annuel : ', round(tx * 100,2), '%'))

```

### Taux de sinistre par variable :

#### FORMULE

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'FORMULE'

res<-resume(df, feature)

res$table
res$fig
res$figyr

```

**ENSEIGNEMENT** : Le comportement observé est stable dans le temps.
Les niveaux `CONFORT` et `ESSENTIEL` semblent avoir un niveau de risque de fréquence équivalent

#### TYPE_RESIDENCE

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'TYPE_RESIDENCE'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Le comportement observé est stable dans le temps.
Les résidences `SECONDAIRE` ont systématiquement une fréquence moindre

#### TYPE_HABITATION

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'TYPE_HABITATION'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Le comportement observé **N'est PAS** stable dans le temps.
Le type d'habitation est à exclure.

#### NB_PIECES

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NB_PIECES'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Le `NB_PIECES` présente des valeurs manquantes.
La fréquence tend à augmenter avec le nombre de pièces.

#### SITUATION_JURIDIQUE

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'SITUATION_JURIDIQUE'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Les propriétaires semblent avoir un fréquence moindre que les locataires de manière consistante, mais avec de la variabilité.

#### NIVEAU_JURIDIQUE

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NIVEAU_JURIDIQUE'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Le `NIVEAU_JURIDIQUE` **N'est PAS** stable dans le temps.
A exclure.

#### VALEUR_DES_BIENS

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'VALEUR_DES_BIENS'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : La fréquence augmente globalement avec la valeur des biens selon une relation non linéaire Par ailleurs au delà de 50k, l'expérience n'est pas stable.
Les modalités supérieures à 80K devraient être groupées.

#### OBJETS_DE_VALEUR

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'OBJETS_DE_VALEUR'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Le `NIVEAU_2` présente une fréquence significativement plus élevée.

#### ZONIER

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'ZONIER'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Le `ZONIER` présente une fréquence avec beaucoup de variabilité, mais il semble y avoir une croissance par région qu'on peut tester :

```{r echo=FALSE, message=FALSE}

df = mrh_train


test <- df %>% mutate(REGION = substr(ZONIER, 1,1))

feature = 'REGION'


res<-resume(test, feature)

res$table
res$fig
res$figyr

```

#### NBSIN_TYPE1_AN1

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NBSIN_TYPE1_AN1'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : La fréquence augmente globalement avec le nombre de sinistres de type 1 l'année précédente.
Toutefois, il semble surtout q'il existe un effet d'une indicatrice a eu sinistre ou non.

#### NBSIN_TYPE1_AN2

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NBSIN_TYPE1_AN2'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ATTENTION** : comme la table ci-dessous le démontre, cette variable présente un problème puisque toutes les lignes ont au moins un sinistre

Comme discuté dans le hackathon **on ignore cette variable**

#### NBSIN_TYPE1_AN3

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NBSIN_TYPE1_AN3'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : La fréquence augmente globalement avec le nombre de sinistres de type 1 il y a 3 ans.
Toutefois, il semble surtout q'il existe un effet d'une indicatrice a eu sinistre ou non.

#### NBSIN_TYPE2_AN1

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NBSIN_TYPE2_AN1'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Il n'existe pas de lien stable sur la fréquence.
A ne pas retenir.

#### NBSIN_TYPE2_AN2

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NBSIN_TYPE2_AN2'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Il n'existe pas de lien stable sur la fréquence.
A ne pas retenir.

#### NBSIN_TYPE2_AN3

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NBSIN_TYPE2_AN3'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Il n'existe pas de lien stable sur la fréquence.
A ne pas retenir.

#### ANNEE

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'ANNEE'

res<-resume(df, feature)

res$table
res$fig
```

**ENSEIGNEMENT** : L'année 2016 semble atypique.
Le niveau actuel semble plus proche de ceux de 2017 et 2018.

### Nettoyage des données

```{r}

preprocess<- function(dt) {
            res <- dt %>%
            mutate( 
              Y = NB/EXPO, #calcul de la fréquence pour XGB qui ne supporte pas les offset, mais accepte les poids
              NB_PIECES = ifelse(is.na(NB_PIECES), 2, NB_PIECES), #2 est le mode de NB_PIECES
              NBSIN_TYPE1_AN1 = ifelse(NBSIN_TYPE1_AN1==0,0,1), #On regroupe les modalités non stables dans le temps
              NBSIN_TYPE1_AN3 = ifelse(NBSIN_TYPE1_AN3==0,0,1), #On regroupe les modalités non stables dans le temps
              REGION =  gsub('[0-9]', '', ZONIER), #création de région
              VALEUR_DES_BIENS = pmin(VALEUR_DES_BIENS, 50000), # On regroupe les valeurs des biens supérieurs à 80k
              OFFSET = log(EXPO) # création d'une variable d'offset qui servira pour le gbm
            ) %>%
            mutate( REGION = as.factor(REGION),
                    VALEUR_DES_BIENS = as.factor(VALEUR_DES_BIENS)
            ) %>%
            select(-c('X', 'TYPE_HABITATION', 'NIVEAU_JURIDIQUE', 'NBSIN_TYPE1_AN2', 'NBSIN_TYPE2_AN1', 'NBSIN_TYPE2_AN2', 'NBSIN_TYPE2_AN3', 'ZONIER'  )) %>% # On supprime les variables sans lien stable dans le temps
            relocate('id', 'EXPO', 'FORMULE', 'TYPE_RESIDENCE', 'SITUATION_JURIDIQUE', 'OBJETS_DE_VALEUR', 'VALEUR_DES_BIENS', 'NB_PIECES',  'REGION', 'NBSIN_TYPE1_AN1', 'NBSIN_TYPE1_AN3', 'ANNEE', 'NB', 'Y', 'COUT' )

            return(res)
}

df_train <- preprocess(mrh_train)
df_val <- preprocess(mrh_val)
df_test <- preprocess(mrh_test)
```

### Calcul du V de Cramer

On mesude l'association des variables entre elles

```{r}
X_train <- df_train %>% select(-c('id', 'EXPO', 'NB', 'Y', 'COUT'))


# Initialize empty matrix to store coefficients
empty_m <- matrix(ncol = length(X_train),
            nrow = length(X_train),
            dimnames = list(names(X_train), 
                            names(X_train)))
# Function that accepts matrix for coefficients and data and returns a correlation matrix
calculate_cramer <- function(m, df) {
 for (r in seq(nrow(m))){
   for (c in seq(ncol(m))){
     m[[r, c]] <- lsr::cramersV(X_train[[r]], X_train[[c]])
   }
 }
    return(m)
}

cor_matrix <- calculate_cramer(empty_m ,X_train)

corrplot(cor_matrix)

```

# Modélisation de la fréquence

Dans cette partie, on essaye de modéliser la fréquence des sinistres.

```{r}
summary(df_test$NB)
```

## Modèle de référence

On commence par une modélisation de référence réduite à un modèle GLM POisson avec un unique intercept.

```{r}
reg0 = glm(NB~1+offset(OFFSET),family=poisson,data=df_train)

summary(reg0)
```

## Modèle GLM plus élaboré

Il s'agit d'un modèle GLM Poisson classique tirant partie des enseignements de la partie précédente, sans interaction.
Les variables sont traitées comme catégorielles pour permettre les effets non linéaires.

```{r}

fit_glm <- glm(NB ~ FORMULE + TYPE_RESIDENCE + SITUATION_JURIDIQUE + OBJETS_DE_VALEUR + as.factor(VALEUR_DES_BIENS) + as.factor(NB_PIECES) + REGION + as.factor(NBSIN_TYPE1_AN1) + as.factor(NBSIN_TYPE1_AN3) + as.factor(ANNEE), 
              data=df_train, offset=OFFSET, family=quasipoisson())

summary(fit_glm)
```

Le modèle n'explique qu'une faible partie de la variabilité.

Par ailleurs la variable SITUATION_JURIDIQUE (qui n'a que 2 niveaux) n'a finalement pas d'impact sur le risque et peut donc être exclue du modèle :

```{r}

fit_glm <- glm(NB ~ FORMULE + TYPE_RESIDENCE + OBJETS_DE_VALEUR + as.factor(VALEUR_DES_BIENS) + as.factor(NB_PIECES) + REGION + as.factor(NBSIN_TYPE1_AN1) + as.factor(NBSIN_TYPE1_AN3) + as.factor(ANNEE), 
              data=df_train, offset=OFFSET, family=quasipoisson())

summary(fit_glm)
```

```{r}

fit_glm_Diag <- data.frame(df_test,
                     fit = predict(fit_glm, newdata = df_test, type="response")
                     ) %>%
                     mutate(pearson = (NB-fit)/sqrt(fit))

dat <- fit_glm_Diag %>%
       select( fit, pearson) %>%
       mutate(quantile = ntile(fit, 16000)) %>%
       group_by(quantile) %>%
       summarize(mean_fit = mean(fit, na.rm = TRUE), mean_pearson = mean(pearson, na.rm = TRUE))


ggplot(dat, aes(x = mean_fit, y = mean_pearson)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 0, size = 1, color="red") + 
  ggtitle("Rédidus de Pearson aggrégés - test - GLM")
  
```

```{r}
round(sum(fit_glm_Diag$fit)/sum(df_test$EXPO),4)

round(sum(df_test$NB)/sum(df_test$EXPO),4)
```

```{r}
fit_glm_Diag %>% 
  mutate(residual = NB-fit) %>%
  summarize(rmse  = sqrt(mean(residual^2)))
```


## Modèle de Gradient Boosting

Pour la mise en place d'un modèle GBM, nous utiliserons le package `h2o` :

```{r echo=T, results='hide', message=FALSE, warning=FALSE}
h2o.init(nthreads = -1)
```

```{r}
h2o.no_progress()
```

Ce package permet de définir une [fonction de perte](https://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/algo-params/distribution.html) correspondant à la déviance de Poisson avec sa fonction de lien canonique, c'est à dire le `ln` dans notre cas.
Par ailleurs, la méthode permet de définir une colonne qui peut servir d'offset.
D'après la [documentation](https://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/gbm.html), cet offset est appliqué dans l'espace linéarisé :

> For other distributions, the offset corrections are applied in the linearized space before applying the inverse link function to get the actual response values.

Il nous faut donc passer en valeur le $ln(EXPO)$ que nous avons renseigné dans la variable `OFFSET` :

En complément nous mettons en oeuvre une recherche par grille pour trouver le métaparamètre de profondeur d'arbre optimal. Le code est adapté de [cet article](https://www.h2o.ai/blog/h2o-gbm-tuning-tutorial-for-r/)

```{r}
hyper_params = list( max_depth = seq(1,15,2) )

grid <- h2o.grid(
  ## hyper parameters
  hyper_params = hyper_params,
  ## full Cartesian hyper-parameter search
  search_criteria = list(strategy = "Cartesian"),
  ## which algorithm to run
  algorithm="gbm",
  ## identifier for the grid, to later retrieve it
  grid_id="Grid_gbm_offset",
  ## standard model parameters
  distribution = "poisson",
  x = names(df_train)[3:12],
  y = 'NB',
  offset_column = "OFFSET",
  training_frame = as.h2o(df_train),
  validation_frame = as.h2o(df_val),

  ## more trees is better if the learning rate is small enough
  ## here, use "more than enough" trees - we have early stopping
  ntrees = 10000,
  ## smaller learning rate is better
  ## since we have learning_rate_annealing, we can afford to start with a bigger learning rate
  learn_rate = 0.05,
  ## learning rate annealing: learning_rate shrinks by 1% after every tree
  ## (use 1.00 to disable, but then lower the learning_rate)
  learn_rate_annealing = 0.99,
  ## sample 80% of rows per tree
  sample_rate = 0.8,
  ## sample 80% of columns per split
  col_sample_rate = 0.8,
  ## fix a random number generator seed for reproducibility
  seed = 1234,
  ## early stopping once the validation AUC doesn't improve by at least 0.01% for 5 consecutive scoring events
  stopping_rounds = 5,
  stopping_tolerance = 1e-4,
  stopping_metric = "deviance",
  ## score every 10 trees to make early stopping reproducible (it depends on the scoring interval)
  score_tree_interval = 10
)
## by default, display the grid search results sorted by increasing logloss (since this is a classification task)
grid

```

On récupère le meilleur modèle :
```{r}
fit_gbm <- h2o.getModel(grid@model_ids[[1]])

```

On vérifie la selection en comparant les performances sur le jeu de validation par rapport aux valeurs affichées dans la grille :
```{r}
print(h2o.performance(fit_gbm, newdata = as.h2o(df_val)))
```

```{r}
plot(fit_gbm)
```

```{r}
h2o.performance(fit_gbm, newdata = as.h2o(df_test))
```

```{r}
fit_gbm_Diag <- data.frame(df_test,
                     fit = as.vector(h2o.predict(object = fit_gbm, newdata=as.h2o(df_test)))
                     ) %>%
                     mutate(pearson = (NB-fit)/sqrt(fit))


dat_gbm <- fit_gbm_Diag %>%
       select( fit, pearson) %>%
       mutate(quantile = ntile(fit, 16000)) %>%
       group_by(quantile) %>%
       summarize(mean_fit = mean(fit, na.rm = TRUE), mean_pearson = mean(pearson, na.rm = TRUE))


ggplot(dat_gbm, aes(x = mean_fit, y = mean_pearson)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 0, size = 1, color="red") + 
  ggtitle("Rédidus de Pearson aggrégés - test - GBM")

```


```{r}
fit_gbm_Diag %>% 
  mutate(residual = NB-fit) %>%
  summarize(rmse  = sqrt(mean(residual^2)))
```

## Modèle de XGBoost

```{r}
x <- c('FORMULE', 'TYPE_RESIDENCE', 'SITUATION_JURIDIQUE','OBJETS_DE_VALEUR', 'VALEUR_DES_BIENS', 'NB_PIECES', 'REGION', 'NBSIN_TYPE1_AN1', 'NBSIN_TYPE1_AN3', 'ANNEE')
y <- 'Y'
w <- 'EXPO'
```

```{r}
# Input maker
prep_xgb <- function(dat, x) {
  data.matrix(dat[, x, drop = FALSE])
}
# Data interface to XGBoost
dtrain <- xgb.DMatrix(
  prep_xgb(df_train, x), 
  label = df_train[[y]], 
  weight = df_train[[w]]
)
# Parameters chosen by 5-fold grouped CV
params_freq <- list(
  learning_rate = 0.2,
  max_depth = 5,
  alpha = 3,
  lambda = 0.5,
  max_delta_step = 2,
  min_split_loss = 0,
  colsample_bytree = 1,
  subsample = 0.9
)



# Fit
set.seed(1)
fit_xgb <- xgb.train(
  params_freq, 
  data = dtrain,
  nrounds = 580,
  objective = "count:poisson",
  watchlist = list(train = dtrain),
  print_every_n = 100
)

# Save and load model
xgb.save(fit_xgb, "xgb.model")
fit_xgb <- xgb.load("xgb.model")

```

```{r}
fit_xgb_Diag <- data.frame(df_test,
                     fit = predict(fit_xgb, prep_xgb(df_test, x))
                     ) %>%
                     mutate(pearson = (NB-fit)/sqrt(fit))


dat_xgb <- fit_xgb_Diag %>%
       select( fit, pearson) %>%
       mutate(quantile = ntile(fit, 16000)) %>%
       group_by(quantile) %>%
       summarize(mean_fit = mean(fit, na.rm = TRUE), mean_pearson = mean(pearson, na.rm = TRUE))


ggplot(dat_xgb, aes(x = mean_fit, y = mean_pearson)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 0, size = 1, color="red") + 
  ggtitle("Rédidus de Pearson aggrégés - test - XGB")

```


```{r}
fit_xgb_Diag %>% 
  mutate(residual = NB-fit) %>%
  summarize(rmse  = sqrt(mean(residual^2)))
```



# Explicabilité des modèles produits

Cette section se consacre à l'explicabilité des modèles produits dans le but d'identifier la manière dont les modèles ML exploitent les combinaisons de variables et effets non linéaires.

Cette section s'appuie sur les travaux présentés dans [Peeking into the black box](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3595944) de Christian Lorentzen et Michael Mayer

## Modèles de prédiction

La première étape consiste à définir des objets génériques pour obtenir des prédiction des modèles.
Nous allons nous appuyer sur le package [flashlight](https://cran.r-project.org/web/packages/flashlight/vignettes/flashlight.html) en définissant un objet par modèle, mais qui aura par la suite le même structure d'appel.

```{r}
fl_glm <- flashlight(
  model = fit_glm, label = "GLM", 
  predict_function = function(fit, X) predict(fit, X, type = "response")
)

fl_xgb <- flashlight(
  model = fit_xgb, label = "XGBoost", 
  predict_function = function(fit, X) predict(fit, prep_xgb(X, x))
)

fl_gbm <- flashlight(
  model = fit_gbm, label = "H20 GBM", 
  predict_function = function(fit, X) as.vector(h2o.predict(object = fit_gbm, newdata=as.h2o(X)))
)


# On combine les différents modèles dans un objet unique disposant des métriques définies ci-dessous
metrics <- list(
                `Déviance Poisson` = deviance_poisson, 
                `R² Déviance Poisson` = r_squared_poisson)


fls <- multiflashlight(list(fl_glm, fl_xgb, fl_gbm), data = df_test, 
                       y = y, w = w, metrics = metrics)


# Variation de l'objet précédent dans l'espace linéarisé
fls_log <- multiflashlight(fls, linkinv = log)
```

## Comparaison de la performance des modèles

On commence par comparer la performance globale des modèles ajustés jusqu'à maintenant :

```{r}
fillc <- "#E69F00"
perf <- light_performance(fls)
perf
plot(perf, geom = "point") +
  labs(x = element_blank(), y = element_blank())
```

Du point de vue de la déviance de Poisson, les différents modèles présentent des performances comparables avec un léger avantage au modèke XGBoost.
C'est un des éléments qui était préssenti : le jeu de donné ne semble pas permettre une mise en avant des méthodes non linéaires.
Un des poinst saillants est la faible fréquence moyenne observée de l'orde de 2,12% soit un écart type de 14,55%.

```{r}
sprintf('férquence moyenne : %.2f%%', tx*100)
sprintf('férquence écart type : %.2f%%', sqrt(tx)*100)
```

Cela explique en partie la faible part de variabilité expliquée par les modèles.

## Importance

On peut ensuite regarder l'importance (au sens permutation) des variables dans chaque modèle.
Une version de décomposition de Shapley est disponible mais trop lente pour les moyens à disposition pour ce projet.

```{r}
imp <- light_importance(fls, v = x, type = 'permutation')
plot(imp, fill = fillc, color = "black")
```

### Partial dependence curves

Pour comprendre la manière dont les différentes varoables contribuent en moyennes au prédiction des modèles on peut s'appuyer sur les pdp.
On représente ici les pdp des 3 variables les plus importantes à priori issues de la section précédente :

```{r}
plot(light_profile(fls, v = "REGION"))
plot(light_profile(fls, v = "VALEUR_DES_BIENS"))
plot(light_profile(fls, v = "FORMULE"))

```

On peut remarquer que si de légères différences existent dans le niveau relatif de chaque modalité, les 3 modèles sont globalement en accord sur la forme des réponses.

### Comparaison des différences de prise en compte de l'effet de la variable VALEUR_DES_BIENS

Dans le graphique ci-dessous on superpose le tri à plat des réponses observées, des prédictions du modèle (en prenant toutes les variables en considération) et les pdp.
Ce graphique donne une intuition de la manière dont un variable contribue en moyenne aux performance du modèle et en fonction des zones sur lesquelles il existe plus ou moins d'exposition.
On y observe par exemple que la réponse combinée du XGBoost est la plus proche de la réponse observée (comme attendu par rapport aux performances globales du modèle).

```{r}
eff_VALEUR_DES_BIENS <- light_effects(fls, v = "VALEUR_DES_BIENS", counts_weighted = TRUE)
p <- plot(eff_VALEUR_DES_BIENS, show_points = FALSE)
plot_counts(p, eff_VALEUR_DES_BIENS, alpha = 0.3)
```

Ce qui est plus surprenant c'est le désaccord qu'ont les modèles sur l'effet des biens de 3500 Eur, qui est portant la modalité qui dispose du plus d'exposition.
Le XGBoost y voit :

-   un effet important plus importants que les autres modèles

-   un effet relatif d'un bien à 3500 Eur bien plus important que celui d'un bien de valeur nulle.

### Analyse des intéractions

Un des points délicats de l'analyse des GLM est l'identification des intéractions potentielles à prendre en compte, là où les méthodes à base d'arbre n'ont pas cette difficulté.
Le graphique suivant se base se le H de Friedman qui calcule l'effet de la pdp croisée nette des effets multipliés des pdp univariées :

```{r}
interact_rel <- light_interaction(
  fls_log, 
  v = most_important(imp, 4), 
  take_sqrt = FALSE,
  pairwise = TRUE, 
  use_linkinv = TRUE,
  seed = 61
)
plot(interact_rel, color = "black", fill = fillc, rotate_x = TRUE)
```

On y observe que (par construction) le modèle GLM n'inclut aucune intéraction, là où les modèles XGBoost et GBM en considèrent.
Toutefois les deux modèles d'arbres n'ont pas la même vision de l'importance de ces intéractions.
Si les deux s'accordent sur l'existence d'une intéraction entre VALEUR_DES_BIENS et TYPE_RESIDENCE, XGBoost accorde par ailleurs de l'importance à l'intéraction VALEUR_DES_BIENS et NB_PIECES, là où GBM y voit un intérêt marginal.
Les effets ici sont normalisés.
On peut aussi les représenter dans leur valeur absolue :

```{r}
interact_abs <- light_interaction(
  fls_log, 
  v = most_important(imp, 4), 
  normalize = FALSE,
  pairwise = TRUE, 
  use_linkinv = TRUE,
  seed = 61
)
plot(interact_abs, color = "black", fill = fillc, rotate_x = TRUE)
```

### Visualisation

Pour essayer de comprendre la forme de ces intéractions, on peut représenter les pdp d'une variable en fonction des modalités d'une autre :

```{r}
#Intéractions fortes
pdp_VALEUR_DES_BIENS_NB_PIECES <- light_profile(fls_log, v = "VALEUR_DES_BIENS", by = "NB_PIECES", 
                                  pd_seed = 50, data = df_val, counts_weighted=TRUE)
plot(pdp_VALEUR_DES_BIENS_NB_PIECES)


pdp_VALEURDESBIENS_TYPE_RESIDENCE <- light_profile(fls_log, v = "VALEUR_DES_BIENS", by = "TYPE_RESIDENCE", 
                                  pd_seed = 50, data = df_val, counts_weighted=TRUE)
plot(pdp_VALEURDESBIENS_TYPE_RESIDENCE)


# Intéractions faibles
pdp_TYPE_RESIDENCE_NB_PIECES <- light_profile(fls_log, v = "TYPE_RESIDENCE", 
                                 by = "NB_PIECES", pd_seed = 50, data = df_val, counts_weighted=TRUE)
plot(pdp_TYPE_RESIDENCE_NB_PIECES)
```

Le premier graphique entre VALEUR_DES_BIENS et NB_PIECES est très intéressant et illustre à la fois une divergence de vue entre les modèles et explique la forme de la réponse moyenne de la VALER_DES_BIENS du XGBoost précédement vue.

En effet tous les modèles s'accordent sur une croissance du risque avec le nombre de pièces.
Par ailleurs, le GLM comme le XGBoost s'accordent sur un risque très inférieur sur les biens de valeur nulle sans pièces (c'est la limite de cet exercice sur des données anonymisées, il n'est pas possible de revenir auprès du métier pour comprendre le rationnel de ce codage).
Par contre, le GLM, sans intéraction, se voit contraint d'accorder un risque homogène en fonction de la valeur du bien, là où le XGBoost, plus libre accorde un niveau de risque beaucoup plsu important aux biens sans pièce, mais de valeur non nulle.
En outre le XGBoost comme le GBM dans une moindre mesure sur une décroissance du risque des biens de valeur intermédiaire.

En complément XGBoost comme GBM s'accordent sur un plafonnement du risque pour les résidences secondaires en fonction de la valeur des biens (contrairement aux résidences principales).

# Apport dans la modélisation GLM

Fort des constats précédents on peut créer un nouveau GLM incluant une intéraction entre la VALEUR_DES_BIENS et le NB_PIECES.
Cette étape nécessite des allers retours en fonction de l'évolution de la pertinence des variabes dans le modèle suite à cette adjunction.
Idéalement il aurait fallu créer une nouvelle variable NB_PIECES avec 2 modalités 0 et 1+ et créer une intéraction avec cette dernière pour recréer l'effet plateau sans augmenter de manière indue le nombre de paramètres du modèle.

```{r}

fit_glm_opti <- glm(NB ~ FORMULE + TYPE_RESIDENCE + OBJETS_DE_VALEUR + as.factor(VALEUR_DES_BIENS)+ REGION + as.factor(NBSIN_TYPE1_AN1) + as.factor(NBSIN_TYPE1_AN3) + as.factor(ANNEE) + as.factor(VALEUR_DES_BIENS):NB_PIECES,
              data=df_train, offset=OFFSET, family=quasipoisson())

summary(fit_glm_opti)
```

On peut alors rajouter ce modèle à notre corpus et en comparer la performance :

```{r}

fl_glm_opti <- flashlight(
  model = fit_glm_opti, label = "GLM_opti", 
  predict_function = function(fit, X) predict(fit, X, type = "response")
)


# On combine les différents modèles dans un objet unique disposant des métriques définies ci-dessous

fls_opti <- multiflashlight(list(fl_glm, fl_glm_opti, fl_xgb, fl_gbm), data = df_test, 
                       y = y, w = w, metrics = metrics)


# Variation de l'objet précédent dans l'espace linéarisé
fls_log_opti <- multiflashlight(fls, linkinv = log)
```

```{r}
fillc <- "#E69F00"
perf_opti <- light_performance(fls_opti)
perf_opti
plot(perf_opti, geom = "point") +
  labs(x = element_blank(), y = element_blank())
```

Le gain ici reste marginal et mériterait d'être encore travaillé par rapport aux autres intéractions détectées dans les modèles, néanmoins elle illustre la manière dont les enseignements des modèles ML peuvent être explicités et servir de guide dans l'amélioration de modèles GLM.

# Conclusion

Ce TD a été l'occasion de poursuivre le travail entrepris lors du Hackathon.
Ce jeu de données n'était peut-être pas le plus adapté du fait de la simplicité de sa structure et de la faible fréquence et donc l'importance de la variabilité du phénomène suivi.
Néanmoins il nous a permi de remprendre la démarche présentée dans [Peeking into the black box](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3595944) pour illustrer comment les approches de ML peuvent utilement aiguiller le praticien dans la construction des GLM qui sont prédominant dans les études tarifaires en entreprise.
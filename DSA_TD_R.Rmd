---
title: "DSA 2021 - TD R"
author: "Fabien FAIVRE"
date: "18 juillet 2021"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
    number_sections: true
    theme: lumen
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

# Présentation du projet

Ce projet s'inscrit dans le cadre de la formation [DSA](https://www.institut-du-risk-management.fr/nos-formations/formations-certifiantes/certificat-data-science-pour-actuariat/), et évalue l'apprentissage de R réalisé auprès de **Robin RYDER**.

Le thème de ce projet est libre.


> J'ai choisi d'étudier une série d'articles qui m'ont frappé sur la comparaison des approches classiques par modèles linéaires généralisés (`GLM`) et par machine learning (ci après `ML`) dans le cadre de la tarification en assurance non-vie et la manière dont elles pouvaient se compléter.


## Les bonnes propriétés du GLM dans le cadre d'une modélisation de la fréquence de sinistres

Soit $N_{i}$ le nombre de sinistre de la police ${i}$, alors dans le modèle Poisson homogène on suppose $N_{i} \sim \mathscr{P}(\lambda \nu_{i})$ où $\nu_{i}$ est l'exposition au risque de la police $i$, $\lambda$ est la fréquence de sinistre annuelle (homogène sur le portefeuille)et $\mathscr{P}$ la loi de Poisson.
On pose $Y_{i} = \frac{N_{i}}{\nu_{i}}$ la fréquence annuelle des sinistres pour la police $i$ et $ \mathbf{x_{i}} = (x_{1},x_{2},\cdots, x_{q}) $ les $q$ caractéristiques de la police $i$.

En tarification, on suppose dans les faits que $\lambda$ dépend de $\mathbf{x}$, de sorte que $\mathbb{P}[Y=k/\nu] = \mathbb{P}[N=k] = e^{-\lambda(\mathbf{x})\nu} \frac{(\lambda(\mathbf{x})\nu)^{k}}{k!}$ avec $ln(\lambda(\mathbf{x})) = \beta_{0} + \beta_{1}x_{1} + \beta_{2}x_{2} + \cdots + \beta_{q}x_{q} \overset{def}{=} \langle \mathbf{\beta}, \mathbf{x} \rangle$ en complétant $\mathbf{x}$ par $x_{0} = 1$.

Lorsqu'on utilise les approches classiques de GLM, on estime $\hat{\lambda}$ en utilisant l'estimateur du maximum de vraisemblance $\hat{\beta}$ de $\beta$.

Cet estimateur peut être obtenu soit en maximisant la log vraisemblance, soit de manière équivalente en minimisant la déviance de Poisson.

En complément, lorsqu'on utilise un GLM incluant un intercept et sa fonction de lien canonique, l'utilisatiuon d'un estimateur du maximum de vraisemblance apporte de bonnes propriétés pour son usage en tarification dont celle dite de **propriété d'équilibre** (Property 2.4 p33 de [Data Analytics for Non-Life Insurance Pricing](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2870308)), qui précise que :

$\displaystyle\sum_{i=1}^{n} \nu_i\hat{\lambda}(\mathbf{x_{i}}) = \displaystyle\sum_{i=1}^{n} \nu_i exp\langle \mathbf{\hat{\beta}}, \mathbf{x_{i}} \rangle = \displaystyle\sum_{i=1}^{n} N_{i}$

De sorte que le nombre total de sinistres estimés est égale au nombre total de sinistres observés. 

Cette propriété est même plus étendue dans certains modèles GLM, notamment lorsque le modèle poissonien avec lien log (exemple (b) p423 de [A systematic relationship between minimum bias and gener- alized linear models](https://www.casact.org/sites/default/files/2021-02/pubs_proceed_proceed99_99317.pdf)) :  dans ce cas l'équilibre existe au globaldu portefeuille, mais aussi pour chaque classe des variables catégorielles incluses dans le modèle.

**Ces propriétés d'équilibres sont critiques pour un assureur** dans un exercice de tarification, puisqu'elles assurent qu'une structure tarifaire basée sur cette approche lui permettra d'équilibrer (au moins théoriquement) ses encaissement avec les sinistres qu'il s'est engagé à indemniser.

Le GLM est donc interprétable, souple à l'usage et présente des propriétés d'équilibre global et local.
Néanmoins son ajustement nécessite un temps humain important et le praticien doit s'en remettre à son expérience pour estimer les éventuelles interactions à inclure dans son analyse. 

## L'apport et les limites des modèles ML en tarification

Les modèles ML par leur grande flexibilité sont des candidats naturels pour remplacer ou à minima compléter les modèles GLM du fait de leur performance sur une grande variété de cas d'usages ces dernières années.
Toutefois, ces modèles nécessitent qulques ajustements avant de pouvoir être utilisés dans des problèmes de tarification.

### Ajustement #1 : définition de la fonction de perte

Une première adaptation des modèles classiques consiste donc à **définir la déviance de poisson comme fonction de perte des algorithmes de ML**.

C'est notamment l'approche préconisée par dans [Data Analytics for Non-Life Insurance Pricing](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2870308) de Mario V. Wuthrich et Christoph Buser.

Cette approche a notamment conduit à l'article [Boosting insights in insurance tariff plans with tree-based machine learning methods](https://arxiv.org/abs/1904.10890) et la créatuon du package [distRforest](https://github.com/henckr/distRforest).
NB : le package `rpart` inclut la déviance de poisson, mais ne permet de définir simplement une fonction de déviance appropriée pour la sévérité (lognormale ou gamma)

### Limites de la modification de la fonction de perte

La définition d'une fonction de perte appropriée est devenue l'approche par défaut de l'utilisation des méthodes ML en tarification. Néanmoins, dès 2019 Wütrich remarqua que les sinistres estimés par les modèles ML ne correspondaient pas à la sinistralité observée sur le portefeuille, même sur le jeu d'entraînement

> Il semble que l'utilisation directe de modèles de ML, mêmes adaptés pour minimiser la déviance, ne présentent pas les garanties d'équilibre des GLM.

Les modèles de ML permettent une meilleurs corrélation avec la réponse individuelle de chaque police, du fait de la plus grande flexibilité accordée à la forme de la contribution (éventuellement non linéaire) de chaque variable à la sortie. Toutefois, cette meilleure corrélation s'obtient au prix de l'abandon de la notion d'équilibre.
En effet, aucune garantie n'est expressément introduite au global du portefeuille ce qui peut produire des divergences, potentiellement importantes, entre la somme des primes demandées et les sinistres que l'assureur s'est engagé à régler.

Cet effet est attribué par M Wütrich aux conditions d'arrêt précoce des algorithmes d'optimisation utilisés par les modèles ML.

## Pistes de réconciliation des approches GLM et ML pour la tarification

Deux options s'offrent dès lors à l'actuaire :

1. essayer d'extraire des informations de la manière dont les modèles ML ont appris les efefts des variables sur la sortie pour compléter les GLM classiquement manipulés avec l'objectiof de combler en partie l'écart de performance (s'il est important) avec le modèle ML tout en conservant les propriiétés et l'interprétabilité naturelle des modèles GLM. C'est la voie suivie par l'article [Peeking into the black box](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3595944) de Christian Lorentzen et Michael Mayer

2. corriger les approches ML en les combinant avec une approche GLM pour en récupérér les propriétés. Le gain de cette approche devrait être plus important que pour la méthode précédente tout en présentant les propriétés d'équilibre des modèles ML sans toutefois apporter l'interprétabilité de ces modèles. C'est la proposition de  de Michel Denuit, Arthur Charpentier et Julien Trufin dans [Autocalibration and Tweedie-dominance for Insurance Pricing with Machine Learning](https://arxiv.org/abs/2103.03635) repartent du constat de Wütrich et proposent une solution de contournement sous la forme d'un ajustement en deux temps successifs :

    1. Dans un premier temps, un modèle ML est ajusté pour déterminer une première estimation $\hat{\pi}$ des primes théoriques

    2. Dans un deuxième temps, ces primes théoriques $\hat{\pi}$ sont utilisées comme variable entrante d'un modèle d'autocalibration local pour produire des primes corrigées $\widehat{\pi_{BC}}$. 
    Cette méthode consiste à ajuster des modèles GLM locaux réduits à un intercept sur des ensembles de points "proches". La notion de proximité ici se fait qui sont définis à partir de la proximité des primes théoriques estimées par ML $\hat{\pi}$ (l'étape de ML rassemble les observations qui se ressemblent, l'étape locale GLM lisse les écarts entre observations voisines pour retrouver les propriétés d'équilibre).  

## Objectif du projet

Dans ce rapport nous prendrons comme prétexte l'analyse du jeu de données tarifaire d'un portefeuille MRH qui nous avait été confié lors du Hackathon pour explorer ces deux approches.
Ce faisant nous nous écarterons du cadre du Hackathon qui proposait de minimiser le RMSE. 
Par ailleurs, ne disposant pas du jeu de test, nous ne pourrons comparer ces méthodes avec le leaderbord produit à l'occasion de l'événement.

De ce fait, et sans perte de généralité, vis-à-vis du propos des articles, nous nous restreindrons dans la suite de ce document à l'analyse de la seule fréquence des sinistres.

Dans la section suivante nous présenterons le jeu de données avant d'en entreprendre la modélisation. La dernière section traitera des approches mises en places dans les articles.


# Analyse

## Mise en place de l'environnement

Le code suivant est un ensemble d'utilitaire pour naviguer dans les répertoires relatifs du projet et installer ou charger les packages nécessaires à l'analyse :

```{r echo=T, results='hide', message=FALSE, warning=FALSE}
if (!require("here")){ 
  install.packages("here") 
  library("here")
}

set_here

LoadPackage <- function (load.lib=c("")) {

  install.lib<-load.lib[!load.lib %in% installed.packages()]
  for(lib in install.lib) install.packages(lib,dependencies=TRUE)
  sapply(load.lib,require,character=TRUE)
  
}


LoadPackage(c('ggplot2', 'dplyr', 'formattable', 'DT', 'tidyr', 'caret', 'plotly', 'xgboost', 'flashlight', 'MetricsWeighted', 'corrplot', 'lsr', 'h2o'))
```

## code

```{r echo=T}


plot_obs<-function(df,feature,use_year=T) {

    if (use_year) {
          dt <-df %>%
          group_by(df[[feature]], ANNEE, .drop=FALSE) %>%
          summarise(Freq = sum(NB*EXPO)/sum(EXPO), nb_lignes = n(), EXPO=sum(EXPO) ,  pct_EXPO = sum(EXPO) /  sum(df$EXPO)) %>%
          rename(feat = 'df[[feature]]') 
    } else {
          dt <-df %>%
          group_by(df[[feature]], .drop=FALSE) %>%
          summarise(Freq = sum(NB*EXPO)/sum(EXPO), nb_lignes = n(), EXPO=sum(EXPO) ,  pct_EXPO = sum(EXPO) /  sum(df$EXPO)) %>%
          rename(feat = 'df[[feature]]') 
    }
    
    
    
    fig <-plot_ly()
    fig <- fig %>% layout(title = paste0('Fréquence de sinistres par ', feature),
             xaxis = list(title = feature),
             yaxis = list(side = 'left', title = 'Exposition', showgrid = FALSE, zeroline = FALSE),
             yaxis2 = list(side = 'right', overlaying = "y", title = 'Fréquence', showgrid = FALSE, zeroline = FALSE))
    
    if (use_year) {
        for (year in unique(dt$ANNEE)) {
        
              dt_temp <- dt %>% filter(ANNEE==year)
              fig <- fig %>% add_trace( 
                             x= dt_temp$feat, y= dt_temp$EXPO, type = 'bar', name = paste0('Exposition_', year),
                             hovertemplate = 'Expo: %{y:.0f}<br>'
                          )
              fig<- fig %>% add_trace(
                             x= dt_temp$feat, y= dt_temp$Freq, type = 'scatter', mode = 'lines', yaxis = 'y2', name= paste0('Fréquence_', year),
                             hovertemplate = 'Freq: %{y:.2%}<br>'
                            )
        
        }
    } else {
              dt_temp <- dt 
              fig <- fig %>% add_trace( 
                             x= dt_temp$feat, y= dt_temp$EXPO, type = 'bar', name = 'Exposition',
                             hovertemplate = 'Expo: %{y:.0f}<br>'
                          )
              fig<- fig %>% add_trace(
                             x= dt_temp$feat, y= dt_temp$Freq, type = 'scatter', mode = 'lines', yaxis = 'y2', name= 'Fréquence',
                             hovertemplate = 'Freq: %{y:.2%}<br>'
                            )
      
    }
    
    return(fig) 
}


```

```{r echo=T}
resume <- function(df, feature) {

    dt <-df %>%
      group_by(df[[feature]], .drop=FALSE) %>%
      summarise(Freq = sum(NB*EXPO)/sum(EXPO), nb_lignes = n(), EXPO=sum(EXPO) ,  pct_EXPO = sum(EXPO) /  sum(df$EXPO ))
    
    colnames(dt)[1] <- feature
    
    
    table<- formattable(dt,
                align = c("l", rep("r", NCOL(dt) - 1)),
                list(
                    Freq = percent,
                    nb_lignes= accounting,
                    EXPO = accounting,
                    pct_EXPO = percent
                )
    )
  
    fig1<- plot_obs(df, feature, use_year = F)
    
    fig2<- plot_obs(df, feature, use_year = T)
    
    return(list(dt=dt, table=table, fig=fig1, figyr=fig2))
}
```

# Présentation du jeu de données

Le jeu de données est constitué de 4 fichiers :

```{r data}
list.files(path=here('data', 'raw'))
```

Le projet suit un portefeuille d'assurance MRH suivi sur plusieurs années de 2016 à 2018 inclus. L'objectif initial du Hackathon est d'estimer les primes 2019 sur un échantillon de contrats.

## expo_train

Le fichier `expo_train.csv` contient la liste des contrats en risques historiquement suivis :

```{r}
expo_train = read.table(file = here('data', 'raw', 'expo_train.csv'), header=T, sep=',', dec='.', encoding = 'UTF-8', stringsAsFactors = F)

datatable(head(expo_train))

str(expo_train)
```

Les données ont été prétraitées pour disposer d'**une ligne par période de risque annuelle homogène**.

Pour des raisons d'anonymisation, les identifiants contrats ont été supprimés de sorte qu'il n'est pas possible de suivre l'évolution du risque d'une période sur l'autre. Pour la même raison, il ne sera pas possible dans la construction des jeux de validation et de test de s'assurer que toute l'expérience d'un même assuré est bien intégralement dans un jeu d'entraînement, de validation ou de test.

La signification des colonnes présentes est la suivante :

-  **`X`**:

variable non nommée. Il s'agit d'un artefact du processus de création du fichier initial. **On ne la prend pas en compte**

-  **`EXPO`** :

exposition en année risque du contrat. Sa valeur précalculée pour chaque ligne est comprise entre 0 et 1

-  **`FORMULE`** :

variable catégorielle codant la formule du contrat comprenant 3 niveaux `MEDIUM`, `ESSENTIEL` et `CONFORT`


 -  **`TYPE_RESIDENCE`** :

variable catégorielle codant le fait que le bien est une résidence `PRINCIPALE`, ou `SECONDAIRE`

-  **`TYPE_HABITATION`** :

variable catégorielle codant le fait que le bien est un `APPARTEMENT`, ou une `MAISON`

-  **`NB_PIECES`** :

variable numérique indiquant le nombre de pièces du logement

-  **`SITUATION_JURIDIQUE`** :

variable catégorielle indiquant si le souscripteur est prorpiétaire (`PROPRIO`) ou locataire (`LOCATAIRE`) du logement assuré

- **`NIVEAU_JURIDIQUE`** :

variable catégorielle codant le niveau de couverture de la garantie juridique

-  **`VALEUR_DES_BIENS`** :

variable numérique reflétant la valeur couverte du contenu du logement

- **`OBJETS_DE_VALEUR`** :

variable catégorielle codant le niveau de couverture des objets

- **`ZONIER`** :

variable catégorielle codant la zone du bien assuré. Le code est constitué d'une lettre représentant une zone et d'un nombre représentant une partie de la zone

-  **`NBSIN_TYPE1_AN1`** :

variable numérique indiquant le nombre de sinistre de type 1 l'année précédente

-  **`NBSIN_TYPE1_AN2`** :

variable numérique indiquant le nombre de sinistre de type 1 il y a 2 ans


- **`NBSIN_TYPE1_AN3`** :

variable numérique indiquant le nombre de sinistre de type 1 il y a 3 ans

- **`NBSIN_TYPE2_AN1`** :

variable numérique indiquant le nombre de sinistre de type 2 l'année précédente

-  **`NBSIN_TYPE2_AN2`** :

variable numérique indiquant le nombre de sinistre de type 2 il y a 2 ans

- **`NBSIN_TYPE2_AN3`** :

variable numérique indiquant le nombre de sinistre de type 2 il y a 3 ans

-  **`id`** :

identifiant du risque, clef de jointure

- **`ANNEE`** :

variable catégorielle indiquant l'année d'observation du risque : `2016`, `2017`, `2018`

## sin_train

Le fichier `expo_train.csv` contient la liste des contrats en risques historiquement suivis :

```{r}
sin_train = read.table(file = here('data', 'raw', 'sin_train.csv'), header=T, sep=';', dec=',', encoding = 'UTF-8', stringsAsFactors = F)

datatable(head(sin_train))

str(sin_train)
```

-   **`id`** : identifiant du risque, clef de jointure avec le fichier `expo_train`

-   **`NB`** : Nombre de sinistres de la typologie modélisée (inconnue) sur la période d'observation

```{r echo=FALSE}

dt <-sin_train %>%
  group_by(NB) %>%
  summarise(nb_lignes = n())


formattable(dt,
            align=c('l','r'),
            list(
                nb_lignes= accounting
            )
)


dt %>%
  ggplot( aes(x=as.factor(NB), y=nb_lignes, fill=as.factor(NB))) +
    geom_bar(stat='identity') +
    ggtitle('Distribution NB')+
    xlab('NB') +
    ylab('nombre de lignes') +
    labs(fill = 'NB')
  
```

## fichier combiné

On peut désormais combine les information d'exposition et de sinistres :

```{r}
mrh <- expo_train %>%
      left_join(sin_train, by =c('id','ANNEE')) %>%
      replace_na(list('NB'=0, 'COUT'=0))
```

N'ayant pas accès au fichier de test utilisé lors du Hackathon, on dissocie ici le fichier mrh en un fichier `train` (70%), un fichier `val` (20%) et un fichier `test` (10%)

```{r}
set.seed(42)

trainIndex<- createDataPartition(mrh$NB>=0, p=.7, list=FALSE, time=1)

mrh_train<-mrh[trainIndex,]
mrh_test<-mrh[ -trainIndex,]

valIndex<- createDataPartition(mrh_test$NB>=0, p=.66, list=FALSE, time=1)
mrh_val<-mrh_test[ valIndex,]
mrh_test<-mrh_test[ -valIndex,]

```

### Taux de sinistres moyen :

```{r}
tx <- sum(mrh_train$NB)/sum(mrh_train$EXPO)

print(paste0('taux de sinistre moyen annuel : ', round(tx * 100,2), '%'))

```

### Taux de sinistre par variable :

#### FORMULE

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'FORMULE'

res<-resume(df, feature)

res$table
res$fig
res$figyr

```

**ENSEIGNEMENT** : Le comportement observé est stable dans le temps. Les niveaux `CONFORT` et `ESSENTIEL` semblent avoir un niveau de risque de fréquence équivalent

#### TYPE_RESIDENCE

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'TYPE_RESIDENCE'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Le comportement observé est stable dans le temps. Les résidences `SECONDAIRE` ont systématiquement une fréquence moindre

#### TYPE_HABITATION

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'TYPE_HABITATION'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Le comportement observé **N'est PAS** stable dans le temps. Le type d'habitation est à exclure.

#### NB_PIECES

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NB_PIECES'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Le `NB_PIECES` présente des valeurs manquantes. La fréquence tend à augmenter avec le nombre de pièces.

#### SITUATION_JURIDIQUE

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'SITUATION_JURIDIQUE'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Les propriétaires semblent avoir un fréquence moindre que les locataires de manière consistante, mais avec de la variabilité.

#### NIVEAU_JURIDIQUE

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NIVEAU_JURIDIQUE'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Le `NIVEAU_JURIDIQUE` **N'est PAS** stable dans le temps. A exclure.

#### VALEUR_DES_BIENS

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'VALEUR_DES_BIENS'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : La fréquence augmente globalement avec la valeur des biens selon une relation non linéaire

#### OBJETS_DE_VALEUR

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'OBJETS_DE_VALEUR'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Le `NIVEAU_2` présente une fréquence significativement plus élevée.

#### ZONIER

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'ZONIER'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Le `ZONIER` présente une fréquence avec beaucoup de variabilité, mais il semble y avoir une croissance par région qu'on peut tester :

```{r echo=FALSE, message=FALSE}

df = mrh_train


test <- df %>% mutate(REGION = substr(ZONIER, 1,1))

feature = 'REGION'


res<-resume(test, feature)

res$table
res$fig
res$figyr

```

#### NBSIN_TYPE1_AN1

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NBSIN_TYPE1_AN1'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : La fréquence augmente globalement avec le nombre de sinistres de type 1 l'année précédente. Toutefois, il semble surtout q'il existe un effet d'une indicatrice a eu sinistre ou non.

#### NBSIN_TYPE1_AN2

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NBSIN_TYPE1_AN2'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ATTENTION** : comme la table ci-dessous le démontre, cette variable présente un problème puisque toutes les lignes ont au moins un sinistre

Comme discuté dans le hackathon **on ignore cette variable**

#### NBSIN_TYPE1_AN3

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NBSIN_TYPE1_AN3'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : La fréquence augmente globalement avec le nombre de sinistres de type 1 il y a 3 ans. Toutefois, il semble surtout q'il existe un effet d'une indicatrice a eu sinistre ou non.

#### NBSIN_TYPE2_AN1

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NBSIN_TYPE2_AN1'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Il n'existe pas de lien stable sur la fréquence. A ne pas retenir.

#### NBSIN_TYPE2_AN2

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NBSIN_TYPE2_AN2'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Il n'existe pas de lien stable sur la fréquence. A ne pas retenir.

#### NBSIN_TYPE2_AN3

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'NBSIN_TYPE2_AN3'

res<-resume(df, feature)

res$table
res$fig
res$figyr
```

**ENSEIGNEMENT** : Il n'existe pas de lien stable sur la fréquence. A ne pas retenir.

#### ANNEE

```{r echo=FALSE, message=FALSE}

df = mrh_train
feature = 'ANNEE'

res<-resume(df, feature)

res$table
res$fig
```

**ENSEIGNEMENT** : L'année 2016 semble atypique. Le niveau actuel semble plus proche de ceux de 2017 et 2018.

### Nettoyage des données

```{r}

preprocess<- function(dt) {
            res <- dt %>%
            mutate( 
              NB_PIECES = ifelse(is.na(NB_PIECES), 2, NB_PIECES), #2 est le mode de NB_PIECES
              NBSIN_TYPE1_AN1 = ifelse(NBSIN_TYPE1_AN1==0,0,1), #On regroupe les modalités non stables dans le temps
              NBSIN_TYPE1_AN3 = ifelse(NBSIN_TYPE1_AN3==0,0,1), #On regroupe les modalités non stables dans le temps
              REGION =  gsub('[0-9]', '', ZONIER), #création de région
              OFFSET = log(EXPO) # création d'une variable d'offset qui servira pour le gbm
            ) %>%
            select(-c('X', 'TYPE_HABITATION', 'NIVEAU_JURIDIQUE', 'NBSIN_TYPE1_AN2', 'NBSIN_TYPE2_AN1', 'NBSIN_TYPE2_AN2', 'NBSIN_TYPE2_AN3'  )) %>% # On supprime les variables sans lien stable dans le temps
            relocate('id', 'EXPO', 'FORMULE', 'TYPE_RESIDENCE', 'SITUATION_JURIDIQUE', 'OBJETS_DE_VALEUR', 'VALEUR_DES_BIENS', 'NB_PIECES', 'ZONIER', 'REGION', 'NBSIN_TYPE1_AN1', 'NBSIN_TYPE1_AN3', 'ANNEE', 'NB', 'COUT' )

            return(res)
}

df_train <- preprocess(mrh_train)
df_val <- preprocess(mrh_val)
df_test <- preprocess(mrh_test)
```

### Calcul du V de Cramer

On mesude l'association des variables entre elles

```{r}
X_train <- df_train %>% select(-c('id', 'EXPO', 'NB', 'COUT'))


# Initialize empty matrix to store coefficients
empty_m <- matrix(ncol = length(X_train),
            nrow = length(X_train),
            dimnames = list(names(X_train), 
                            names(X_train)))
# Function that accepts matrix for coefficients and data and returns a correlation matrix
calculate_cramer <- function(m, df) {
 for (r in seq(nrow(m))){
   for (c in seq(ncol(m))){
     m[[r, c]] <- lsr::cramersV(X_train[[r]], X_train[[c]])
   }
 }
    return(m)
}

cor_matrix <- calculate_cramer(empty_m ,X_train)

corrplot(cor_matrix)

```

# Modélisation de la fréquence

Dans cette partie, on essaye de modéliser la fréquence des sinistres.


## Modèle de référence
On commence par une modélisation de référence réduite à un modèle GLM POisson avec un unique intercept.
```{r}
reg0 = glm(NB~1+offset(OFFSET),family=poisson,data=df_train)

summary(reg0)
```

## Modèle GLM plus élaboré
Il s'agit d'un modèle GLM Poisson classique tirant partie des enseignements de la partie précédente, sans interaction. Les variables sont traitées comme catégorielles pour permettre les effets non linéaires.

```{r}

fit_glm <- glm(NB ~ FORMULE + TYPE_RESIDENCE + SITUATION_JURIDIQUE + OBJETS_DE_VALEUR + as.factor(VALEUR_DES_BIENS) + as.factor(NB_PIECES) + REGION + as.factor(NBSIN_TYPE1_AN1) + as.factor(NBSIN_TYPE1_AN3) + as.factor(ANNEE), 
              data=df_train, offset=OFFSET, family=quasipoisson())

summary(fit_glm)
```
Le modèle n'explique qu'une faible partie de la variabilité.

```{r}
fit_glm_Diag <- data.frame(df_train,
                     link = predict(fit_glm, type = "link"),
                     fit = predict(fit_glm, type = "response"),
                     pearson = residuals(fit_glm, type = "pearson"),
                     resid = residuals(fit_glm, type = "response"),
                     residSqr = residuals(fit_glm, type = "response")^2
                     )

```

```{r}

dat <- fit_glm_Diag %>%
       select( fit, pearson) %>%
       mutate(quantile = ntile(fit, 150)) %>%
       group_by(quantile) %>%
       summarize(mean_fit = mean(fit, na.rm = TRUE), mean_pearson = mean(pearson, na.rm = TRUE))


ggplot(dat, aes(x = mean_fit, y = mean_pearson)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 0, size = 1, color="red") + 
  ggtitle("Rédidus de Pearson aggrégés")
  
```




## Modèle de Gradient Boosting

Pour la mise en place d'un modèle GBM, nous utiliserons le package `h2o` :
```{r echo=F}
h2o.init(nthreads = -1)
```

```{r cache=T}
reg_bst_100 = h2o.gbm(y = 'NB', x = names(df_train),
                       distribution = "poisson",
                       offset_column = "OFFSET",
                       training_frame = as.h2o(df_train),
                       validation_frame = as.h2o(df_val),
                       ntrees = 100,
                       nfolds = 5,
                       seed = 1)

```

```{r}
plot(reg_bst_100)
```




```{r}
x <- c('FORMULE', 'TYPE_RESIDENCE', 'SITUATION_JURIDIQUE','OBJETS_DE_VALEUR', 'VALEUR_DES_BIENS', 'NB_PIECES', 'REGION', 'NBSIN_TYPE1_AN1', 'NBSIN_TYPE1_AN3', 'ANNEE')
y <- 'NB'
w <- 'EXPO'
```

```{r}
# Input maker
prep_xgb <- function(dat, x) {
  data.matrix(dat[, x, drop = FALSE])
}
# Data interface to XGBoost
dtrain <- xgb.DMatrix(
  prep_xgb(df_train, x), 
  label = df_train[[y]], 
  weight = df_train[[w]]
)
# Parameters chosen by 5-fold grouped CV
params_freq <- list(
  learning_rate = 0.2,
  max_depth = 5,
  alpha = 3,
  lambda = 0.5,
  max_delta_step = 2,
  min_split_loss = 0,
  colsample_bytree = 1,
  subsample = 0.9
)
# Fit
set.seed(1)
fit_xgb <- xgb.train(
  params_freq, 
  data = dtrain,
  nrounds = 580,
  objective = "count:poisson",
  watchlist = list(train = dtrain),
  print_every_n = 100
)

# Save and load model
xgb.save(fit_xgb, "xgb.model")
fit_xgb <- xgb.load("xgb.model")

```

# Model Explanations

The models are ready, so let's shed light into them.

## Setting up explainers

We start by setting up the explainers. These are basically objects that know how to create predictions.

**Crucial: the prediction function needs to work for subsets of datasets, not just for the original model data set.**

```{r}
fl_glm <- flashlight(
  model = fit_glm, label = "GLM", 
  predict_function = function(fit, X) predict(fit, X, type = "response")
)

fl_xgb <- flashlight(
  model = fit_xgb, label = "XGBoost", 
  predict_function = function(fit, X) predict(fit, prep_xgb(X, x))
)

fl_xgb <- flashlight(
  model = fit_xgb, label = "H20 GBM", 
  predict_function = function(fit, X) predict(fit, prep_xgb(X, x))
)

reg_bst_100



# Combine them and add common elements like reference data
metrics <- list(`Average deviance` = deviance_poisson, 
                `Relative deviance reduction` = r_squared_poisson)
fls <- multiflashlight(list(fl_glm, fl_xgb), data = df_val, 
                       y = y, w = w, metrics = metrics)
# Version on canonical scale
fls_log <- multiflashlight(fls, linkinv = log)
```

## Performance

We start to interpret the models by looking at model performance using deviance related metrics.

```{r}
fillc <- "#E69F00"
perf <- light_performance(fls)
perf
plot(perf, geom = "point") +
  labs(x = element_blank(), y = element_blank())
```

## Importance

Next, we consider permutation variable importance. By default `flashlight` uses the first performance metric specified above.

```{r}
imp <- light_importance(fls, v = x)
plot(imp, fill = fillc, color = "black")
```

### Partial dependence curves

Taking the average of many ICE curves produces the famous partial dependence plot. We consider such plots for four predictors.

```{r}
plot(light_profile(fls, v = "VALEUR_DES_BIENS"))
plot(light_profile(fls, v = "NB_PIECES"))
plot(light_profile(fls, v = "TYPE_RESIDENCE"))

```

## Classic diagnostic plots

Classic predicted/residual/response versus covariable plots are worth a look.

```{r}
# Average predicted versus covariable
plot(light_profile(fls, v = "NB_PIECES", type = "predicted"))
# Average residual versus covariable
plot(light_profile(fls, v = "NB_PIECES", type = "residual")) +
  geom_hline(yintercept = 0)
# Average response versus covariable
plot(light_profile(fls, v = "NB_PIECES", type = "response"))
```

### Multiple aspects combined

We often get a good picture of the effect of a covariable by combining partial dependence with classic plots.

```{r}
eff_DrivAge <- light_effects(fls, v = "NB_PIECES", counts_weighted = TRUE)
p <- plot(eff_DrivAge, show_points = FALSE)
plot_counts(p, eff_DrivAge, alpha = 0.3)
```

```{r}
interact_rel <- light_interaction(
  fls_log, 
  v = most_important(imp, 4), 
  take_sqrt = FALSE,
  pairwise = TRUE, 
  use_linkinv = TRUE,
  seed = 61
)
plot(interact_rel, color = "black", fill = fillc, rotate_x = TRUE)
```

### On absolute scale

```{r}
interact_abs <- light_interaction(
  fls_log, 
  v = most_important(imp, 4), 
  normalize = FALSE,
  pairwise = TRUE, 
  use_linkinv = TRUE,
  seed = 61
)
plot(interact_abs, color = "black", fill = fillc, rotate_x = TRUE)
```

### Visualization

Let's illustrate a strong and a weak interaction by conditional partial dependence plots.

```{r}
# Strong interaction
# p <- plot(eff_DrivAge, show_points = FALSE)
# plot_counts(p, eff_DrivAge, alpha = 0.3)


pdp_NBPIECES_REGION <- light_profile(fls_log, v = "NB_PIECES", by = "REGION", 
                                  pd_seed = 50, data = df_val, counts_weighted=TRUE)
p <- plot(pdp_NBPIECES_REGION, show_points = FALSE)
pdp_count <- light_effects(fls, v = "NB_PIECES")
plot_counts(p, pdp_count, alpha = 0.3)

pdp_VALEURDESBIENS_REGION <- light_profile(fls_log, v = "VALEUR_DES_BIENS", by = "REGION", 
                                  pd_seed = 50, data = df_val, counts_weighted=TRUE)
plot(pdp_VALEURDESBIENS_REGION)

# Weak interaction
pdp_TYPE_RESIDENCE_REGION <- light_profile(fls_log, v = "TYPE_RESIDENCE", 
                                 by = "REGION", pd_seed = 50, data = df_val, counts_weighted=TRUE)
plot(pdp_TYPE_RESIDENCE_REGION)
```

```{r}
summary(df_val$NB/df_val$EXPO)
summary(fl_glm$predict_function(fit_glm, df_val))
summary(fl_xgb$predict_function(fit_xgb, df_val))
```

fls
